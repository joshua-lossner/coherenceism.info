import { readFile } from 'node:fs/promises'
import { OrchestratorInput, OrchestratorResult, Artifact, FrontMatter } from './types'

// Orchestrator STUB â€” no LLM calls; no network calls.
// TODO: Stage graph (actors), planner, gating, QA, and persistence.

interface ConfigShape {
  paths: {
    contentRoot: string
    drafts: string
    journals: string
    research: string
  }
  policies: {
    freshnessDays: number
    minSources: number
    stopOnQAFail: boolean
  }
  workflows: Record<string, { actors: string[]; output: string }>
}

async function loadConfig(): Promise<ConfigShape> {
  const raw = await readFile(process.cwd() + '/orchestration/config.json', 'utf8')
  return JSON.parse(raw)
}

export async function runWorkflow(input: OrchestratorInput): Promise<OrchestratorResult> {
  const logs: string[] = []
  logs.push('orchestrator stub executed')

  const config = await loadConfig()
  const wf = config.workflows[input.workflow]
  if (!wf) {
    throw new Error(`Unknown workflow: ${input.workflow}`)
  }

  const defaults: FrontMatter = {
    title: 'Untitled',
    slug: 'untitled',
    published: false,
    type: (wf.output as FrontMatter['type']) || 'journal',
    tags: [],
    sources: [],
    summary: 'TODO: summary will be generated by orchestrator'
  }

  const frontMatter: FrontMatter = { ...defaults, ...(input.overrides || {}) }

  const artifact: Artifact = {
    frontMatter,
    body: 'TODO: composed by orchestrator',
    qa: {
      passed: false,
      notes: ['QA not run (stub)']
    }
  }

  // TODO: actor execution
  // TODO: gate checks
  // TODO: QA and remediation loop
  // TODO: persistence to /content tree

  return { artifact, logs }
}


